<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <link rel="stylesheet" href="https://courses-at-nju-by-hfwei.github.io/cpl-lectures/node_modules/reveal.js-plugins/chalkboard/style.css">
    <script src="https://courses-at-nju-by-hfwei.github.io/cpl-lectures/node_modules/reveal.js-plugins/chalkboard/plugin.js"></script> 
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex, nofollow">
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
 
    <script>
const copyButtonLabel = "Copy Code";

// use a class selector if available
let blocks = document.querySelectorAll("pre");

blocks.forEach((block) => {
  // only add button if browser supports Clipboard API
  if (navigator.clipboard) {
    let button = document.createElement("button");

    button.innerText = copyButtonLabel;
    block.appendChild(button);

    button.addEventListener("click", async () => {
      await copyCode(block);
    });
  }
});

async function copyCode(block) {
  let code = block.querySelector("code");
  let text = code.innerText;

  await navigator.clipboard.writeText(text);
}
    </script>
      <style>
        body {counter-reset:section;}
        h1 {counter-reset:subsection;font-size:x-large;}
        h2 {font-size: large;}
        
        h1:before {
        counter-increment:section;
        content:counter(section) ". ";
            font-weight:bold;
            font-size: x-large;
        }
        h2:before {
        counter-increment:subsection;
        content:counter(section) "." counter(subsection) " ";
        font-size: large;
        }
        html, body {
            margin: 5%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        } 

        pre {
            font-family: 'Courier New', Courier, monospace;
        } 
        div{
            max-width: 100%;
            overflow: auto;
            
        }
        .navbar {
            overflow: hidden;
            background-color: #333;
            position: fixed; /* Set the navbar to fixed position */
            top: 0; /* Position the navbar at the top of the page */
            width: 100%; /* Full width */
        }

        img {
        max-width: 80%;
        height: auto;
        }
        .navbar a {
            float: left;
            display: block;
            color: #f2f2f2;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }

        a {
            color: #148bca;
            text-align: center;
            padding-left: 2px;
            padding-right: 2px;
            text-decoration: none;
        }

        p.hidden {
          overflow: hidden;
        }

    </style>
  </head>
  <body>
    
    <div class="navbar">
        <a href="https://shzaiz.github.io">AUG's Wiki</a>
        <a href="index.html"> ↑ Back to contents</a>
    </div>

    <div class="toc"></div>
    <a id="toc-button"><i class="far fa-bookmark"></i></a>
    <p>$$
\Huge \left[\left[\sum\right]_{}\right]\\
\small\textbf{etoneWiki}
$$</p>
<p>$$
\Huge \textbf{Cayley&#x27;s formula}\\
\small \texttt{by etone on Combinatorial Mathematics}\\
\texttt{Spring, 2015 at Nanjing University}
$$</p>
<blockquote>
<p>Contents
[toc]{level: [1,2,3,4,5]}</p>
</blockquote>
<h1>Cayley&#x27;s Formula</h1>
<p>We now present a theorem of the number of labeled trees on a fixed number of vertices. It is due to <a href="https://web.archive.org/web/20160906214402/http://en.wikipedia.org/wiki/Arthur_Cayley">Cayley</a> in 1889. The theorem is often referred by the name <a href="https://web.archive.org/web/20160906214402/http://en.wikipedia.org/wiki/Cayley%27s_formula">Cayley&#x27;s formula</a>.</p>
<blockquote>
<p>Cayley&#x27;s formula for trees
There are  \(n^{n − 2}\)  different trees on  \(n\)  distinct vertices.</p>
</blockquote>
<p>The theorem has several proofs, including the bijection which encodes a tree by a <a href="https://web.archive.org/web/20160906214402/http://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence">Prüfer</a> code, through the <a href="https://web.archive.org/web/20160906214402/http://en.wikipedia.org/wiki/Kirchhoff%27s_matrix_tree_theorem">Kirchhoff&#x27;s matrix tree theorem</a>, and by double counting.</p>
<h2>Proof of Cayley&#x27;s formula by double counting</h2>
<p>We now present a double counting proof, which is considered by the <a href="https://web.archive.org/web/20160906214402/http://en.wikipedia.org/wiki/Proofs_from_THE_BOOK">Proofs from THE BOOK</a> &quot;the most beautiful of them all&quot;.</p>
<blockquote>
<p>Proof of Cayley&#x27;s formula by double counting
(Due to Pitman 1999)</p>
<p>Let  \(T_n\)  be the number of different trees defined on  \(n\)  distinct vertices.</p>
<p>A <strong>rooted tree</strong> is a tree with a special vertex. That is, one of the  \(n\)  vertices is marked as the &quot;root&quot; of the tree. A rooted tree defines a natural direction of all edges, such that an edge  \(uv\)  of the tree is directed from  \(u\)  to  \(v\)  if  \(u\)  is before  \(v\)  along the unique path from the root.</p>
<p>We count the number of different sequences of directed edges that can be added to an empty graph on  \(n\)  vertices to form from it a rooted tree. We note that such a sequence can be formed in two ways:</p>
<ul>
<li>Starting with an unrooted tree, choose one of its vertices as root, and fix an total order of edges to specify the order in which the edges are added.</li>
<li>Starting from an empty graph, add the edges one by one in steps.</li>
</ul>
<p>In the first method, we pick one of the  \(T_n\)  unrooted trees, choose one of the  \(n\)  vertices as the root, and pick one of the  \((n − 1)!\)  total orders of the  \(n − 1\)  edges. This gives us  \(T_nn(n − 1)! = T_nn!\)  ways.</p>
<p>In the second method, we consider the number of choices in one step, and multiply the numbers of choices in all steps. This is done as follows.</p>
<p>Given a sequence of adding  \(n − 1\)  edges to an empty graph to form a rooted tree, we reverse this sequence and get a sequence of removing edges one by one from the final rooted tree until no edge left. We observe that:</p>
<ul>
<li>At first, we remove an edge from the rooted tree. Suppose that the root of the tree is  \(r\) , and the removed directed edge is  \((u,v)\) . After removing  \((u,v)\) , the original rooted tree is disconnected into two rooted trees, one rooted at  \(r\)  and the other rooted at  \(v\) .</li>
<li>After removing  \(k − 1\)  edges, there are  \(k\)  rooted trees. In the  \(k\) th step, a directed edge  \((u,v)\)  in the current forest is removed and the tree containing  \((u,v)\)  is disconnected into two trees, one rooted at the old root of that tree, and the other rooted at  \(v\) .</li>
</ul>
<p>We now again reverse the above procedure, and consider the sequence of adding directed edges to an empty graph to form a rooted tree.</p>
<ul>
<li>At first, we have n rooted trees, each of  \(0\)  edge ( \(n\)  isolated vertices).</li>
<li>After adding  \(n − k\)  edges, there are  \(k\)  rooted trees. Denoting the directed edge added next as  \((u,v)\) . As observed above,  \(u\)  can be any one of the  \(n\)  vertices; but  \(v\)  must be the root of one of the  \(k\)  trees, except the tree which contains  \(u\) . There are  \(n(k − 1)\)  choices of such  \((u,v)\) .</li>
</ul>
<p>Multiplying the numbers of choices in all steps, the number of sequences of adding directed edges to an empty graph to form a rooted tree is given by</p>
<p>$$\prod_{k=2}^nn(k-1)=n^{n-2}n!.$$
By the principle of double counting, counting the same thing by different methods yield the same result.</p>
<p>$$T_nn! = n^{n − 2}n!,$$
which gives that  \(T_n = n^n − 2.\) </p>
<p> \(\square\) </p>
</blockquote>
<h1>Prüfer code</h1>
<p>The Prüfer code encodes a labeled tree to a sequence of labels. This gives a bijections between trees and tuples.</p>
<h2>Encoding</h2>
<p>In a tree, the vertices of degree 1 are called leaves. It is easy to see that:</p>
<ul>
<li>each tree has at least two leaves; and</li>
<li>after removing a leaf (along with the edge adjacent to it) from a tree, the resulting graph is still a tree.</li>
</ul>
<p>The following algorithm transforms a tree  \(T\)  of  \(n\)  vertices  \(1,2,\ldots,n\) , to a tuple  \((v_1,v_2,\ldots,v_{n-2})\in\{1,2,\ldots,n\}^{n-2}\) .</p>
<blockquote>
<p>Prüfer code (encoder)
<strong>Input</strong>: A tree  \(T\)  of  \(n\)  distinct vertices, labeled by  \(1,2,\ldots,n\) .</p>
<ul>
<li>let  \(T_1 = T\) ;</li>
<li>for  \(i = 1\)  to  \(n − 1\) , do
<ul>
<li>let  \(u_i\)  be the leaf in  \(T_i\)  with the smallest label, and  \(v_i\)  be its neighbor;</li>
<li>let  \(T_{i + 1}\)  be the new tree obtained from deleting the leaf  \(u_i\)  from  \(T_i\) ;</li>
</ul>
</li>
<li>end</li>
<li>return  \((v_1,v_2,\ldots,v_{n-2})\) ;</li>
</ul>
</blockquote>
<blockquote>
<p>Example</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #666666">1</span><span style="color: #bbbbbb">   </span><span style="color: #666666">2</span><span style="color: #bbbbbb">   </span><span style="color: #666666">3</span><span style="color: #bbbbbb">      </span>
<span style="border: 1px solid #FF0000">|</span><span style="color: #bbbbbb">   </span><span style="border: 1px solid #FF0000">|</span><span style="color: #bbbbbb">   </span><span style="border: 1px solid #FF0000">|</span><span style="color: #bbbbbb">      </span>
<span style="color: #666666">----+----</span><span style="color: #bbbbbb">      </span>
<span style="color: #bbbbbb">    </span><span style="color: #666666">4</span><span style="color: #bbbbbb"> </span><span style="color: #666666">--</span><span style="color: #bbbbbb"> </span><span style="color: #666666">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">--</span><span style="color: #bbbbbb"> </span><span style="color: #666666">6</span>
</pre></div>

<p>Consider the above algorithm run on the tree shown to the right. Initially, vertex 1 is the leaf with the smallest label, so it is removed first and 4 is put in the Prüfer sequence. Vertices 2 and 3 are removed next, so 4 is added twice more. Vertex 4 is now a leaf and has the smallest label, so it is removed and we append 5 to the sequence. We are left with only two vertices, so we stop. The tree&#x27;s sequence is {4,4,4,5}.</p>
</blockquote>
<h2>Decoding</h2>
<p>It is trivial to observe the following lemma:</p>
<blockquote>
<p>Lemma 1
For each  \(1\le i\le n-1\) ,  \(T_i\)  is a tree of  \(n − i + 1\)  vertices. In particular, the vertices of  \(T_i\)  are  \(u_i,u_{i+1},\ldots,u_{n-1},v_{n-1}\) , and the edges of  \(T_i\)  are precisely  \({u_j,v_j}, i\le j\le n-1\) .</p>
</blockquote>
<p>And there is a reason that we do not need to store  \(v_n − 1\)  in the Prüfer code.</p>
<blockquote>
<p>Lemma 2
It always holds that  \(v_n − 1 = n\) .</p>
</blockquote>
<blockquote>
<p>Proof.
Every tree (of at least two vertices) has at least two leaves. The  \(ui, 1\le i\le n-1\) , are the leaf of the smallest label in  \(T_i\) , which can never be  \(n\) , thus  \(n\)  is never deleted.</p>
<p> \(\square\) </p>
</blockquote>
<p>Lemma 1 and 2 together imply that given a Prüfer code  \((v_1,v_2,\ldots,v_{n-2})\) , the only remaining task to reconstruct the tree  \(T\)  is to figure out those  \(u_i, 1\le i\le n-1\) . The following lemma state how to obtain  \(ui, 1\le i\le n-1\) , from a Prüfer code  \((v_1,v_2,\ldots,v_{n-2})\) .</p>
<blockquote>
<p>Lemma 3
For  \(i=1,2,\ldots,n-1\) ,  \(u_i\)  is the smallest element of  \(\{1,2,\ldots,n\}\)  not in  \(\{u_1,\ldots,u_{i-1}\}\cup\{v_i,\ldots,v_{n-1}\}.\) </p>
</blockquote>
<blockquote>
<p>Proof</p>
<p>Note that  \(u_1,u_2,\ldots,u_{n-1},v_{n-1}\)  is a sequence of distinct vertices, because  \(u_1,u_2,\ldots,u_{n-1}\)  are deleted one by one from the tree, and  \(v_n − 1 = n\)  is never deleted. Thus, each vertex  \(v\)  appears among  \(u_1,u_2,\ldots,u_{n-1},v_{n-1}\)  exactly once. And each vertex  \(v\)  appears for  \(\text{deg}(v)\)  times among the edges  \(\{ui,vi\}\) ,  \(1\le i\le n-1\) , where  \(\text{deg}(v)\)  denotes the degree of vertex  \(v\)  in the original tree  \(T\) . Therefore, each vertex  \(v\)  appears among  \(v_1,v_2,\ldots,v_{n-2}\)  for  \(\text{deg}(v) − 1\)  times.</p>
<p>Similarly, each vertex  \(v\)  of  \(T_i\)  appears among  \(v_i,v_{i+1},\ldots,v_{n-2}\)  for  \(\text{deg}_i(v) − 1\)  times, where  \(\text{deg}_i(v)\)  is the degree of vertex  \(v\)  in the tree  \(T_i\) . In particular, the leaves of  \(T_i\)  are not among  \(\{v_i,v_{i+1},\ldots,v_{n-2}\}\) . Recall that the vertices of  \(T_i\)  are  \(u_i,u_{i+1},\ldots,u_{n-1},v_{n-1}\) . Then the leaves of  \(T_i\)  are the elements of  \(\{1,2,\ldots,n\}\)  not in  \(\{u_1,\ldots,u_{i-1}\}\cup\{v_i,\ldots,v_{n-1}\}\) . By definition of Prüfer code,  \(u_i\)  is the leaf in  \(T_i\)  of smallest label, hence the smallest element of  \(\{1,2,\ldots,n\}\)  not in  \(\{u_1,\ldots,u_{i-1}\}\cup\{v_i,\ldots,v_{n-1}\}\) .</p>
<p> \(\square\) </p>
</blockquote>
<p>Applying Lemma 3, we have the following decoder for the Prüfer code:</p>
<blockquote>
<p>Prüfer code (decoder)
<strong>Input</strong>: A tuple  \((v_1,v_2,\ldots,v_{n-2})\in\{1,2,\ldots,n\}^{n-2}\) .</p>
<ul>
<li>let  \(T\)  be empty graph, and  \(v_{n − 1} = n\) ;</li>
<li>for  \(i = 1\)  to  \(n − 1\) , do
<ul>
<li>let  \(u_i\)  be the smallest label not in  \(\{u_1,\ldots,u_{i-1}\}\cup\{v_i,\ldots,v_{n-1}\}\) ;</li>
<li>add an edge  \({u_i,v_i}\)  to  \(T\) ;</li>
</ul>
</li>
<li>end</li>
<li>return  \(T\) ;</li>
</ul>
</blockquote>
<p>In other words, the encoding of trees to tuples by the Prüfer code is reversible, thus the mapping is injective (1-1). To see it is also surjective, we need to show that for every possible  \((v_1,v_2,\ldots,v_{n-2})\in\{1,2,\ldots,n\}^{n-2}\) , the above decoder recovers a tree from it.</p>
<h2>Bijection proof of Cayley&#x27;s formula</h2>
<p>Therefore, the Prüfer code establishes a bijection between the set of trees on n distinct vertices and the tuples from  \(\{1,2,\ldots,n\}^{n-2}\) . This proves Cayley&#x27;s formula.</p>
<h1>Kirchhoff&#x27;s Matrix-Tree Theorem</h1>
<p>Given an undirected graph  \(G([n],E)\) , the <strong>adjacency matrix</strong> A of graph G is an  \(n\times n\)  matrix such that</p>
<p>$$A(i,j)=\begin{cases}
1 &amp; \{i,j\}\in E,\\
0 &amp; \{i,j\}\not\in E.
\end{cases}$$</p>
<h2>Graph Laplacian</h2>
<p>Let  \(D\)  be a  \(n\times n\)  diagonal matrix such that</p>
<p>$$D(i,j)=\begin{cases}
\text{deg}(i) &amp; i=j,\\
0 &amp; i\neq j,
\end{cases}$$
where  \(\text{deg(}i)\)  denotes the degree of vertex  \(i\) .</p>
<p>The Laplacian matrix  \(L\)  of graph  \(G\)  is defined as  \(L = D − A\) , that is,</p>
<p>$$L(i,j)=\begin{cases}
\text{deg}(i) &amp; i=j,\\
-1 &amp; i\neq j\text{ and } \{i,j\}\in E,\\
0 &amp; \text{otherwise}.
\end{cases}$$
Suppose  \(G([n],E)\)  has m edges. The incidence matrix  \(B\)  of graph  \(G\)  is an  \(n\times m\)  matrix such that</p>
<p>$$\forall i\in[n], \forall e\in E,\quad B(i,e)=\begin{cases}
1 &amp; e=\{i,j\}\text{ and } i&lt;j,\\
-1 &amp; e=\{i,j\}\text{ and } i&gt;j,\\
0 &amp; \text{otherwise}.
\end{cases}$$
The following proposition is easy to verify.</p>
<blockquote>
<p>Proposition
$$L = BB^T.$$</p>
</blockquote>
<blockquote>
<p>Proof.
For any  \(i,j\in[n]\) , we have</p>
<p>$$(BB^T)(i,j)=\sum_{e\in E}B(i,e)B^T(e,j)=\sum_{e\in E}B(i,e)B(j,e).$$
It is easy to verify that</p>
<p>$$\sum_{e\in E}B(i,e)B(j,e)=
\begin{cases}
\text{deg}(i) &amp; i=j,\\
-1 &amp; i\neq j\text{ and } \{i,j\}\in E,\\
0 &amp; \text{otherwise},
\end{cases}$$
which is equal to the definition of  \(L\) .</p>
<p> \(\square\) </p>
</blockquote>
<h2>The Matrix-tree Theorem</h2>
<p>The matrix-tree theorem of Kirchhoff states a striking fact: The number of spanning trees in any connected graph can be computed as the determinant of some appropriate graph matrix.</p>
<blockquote>
<p>Kirchhoff&#x27;s Matrix-Tree Theorem
For any connected graph  \(G\)  of n vertices, the number of spanning trees in  \(G\)  is  \(\det(L_{i,i})\,\)  for all  \(i\in[n]\) ,  \(where L_{i,i}\,\)  is the  \((n-1)\times(n-1)\)  matrix resulting from the Laplacian matrix  \(L\)  of graph  \(G\)  by deleting the  \(i\) -th row and the  \(i\) -th column.</p>
</blockquote>
<p>The determinant can be computed as fast as matrix multiplication, thus is quite efficient, especially when compared to our task: counting the number of subgraphs satisfying certain nontrivial global constraint (e.g. spanning tree). Such efficient algorithm is rarely seen for counting problems, which are usually #P-hard to compute (e.g. number of matchings in a graph).</p>
<p>The key to prove the matrix-tree theorem is the Cauchy-Binet theorem in linear algebra, whose proof is beyond the scope of this class.</p>
<blockquote>
<p>Cauchy-Binet Theorem
Let  \(A\)  and  \(B\)  be, respectively,  \(n\times m\)  and  \(m\times n\)  matrix. For any  \(S\subseteq [m]\)  of size  \(n\) , let  \(A_{[n],S}\)  and  \(B_{S,[n]}\)  denote, respectively, the  \(n\times n\)  submatrices of  \(A\)  and  \(B\) , consisting of the columns of  \(A\) , or the rows of  \(B\) , indexed by elements of  \(S\) . Then
$$\det(AB)=\sum_{S\in{[m]\choose n}}\det(A_{[n],S})\det(B_{S,[n]}).$$</p>
</blockquote>
<p>Let  \(B\)  be the incidence matrix of graph  \(G\) . Fix any vertex  \(i\) , let  \(C\)  be the  \((n-1)\times m\)  matrix resulting from  \(B\)  by deleting the  \(i\) -th row.</p>
<p>Recall that  \(L = BB^T\) . It is easy to verify that</p>
<p>$$L_{i,i} = CC^T.$$
Due to the Cauchy-Binet Theorem, we have</p>
<p>$$
\begin{aligned}
\det(L_{i,i})=\det(CC^T)
&amp;=\sum_{S\in{[m]\choose n-1}}\det(C_{[n-1],S})\det(C^T_{S,[n-1]})\\
&amp;=\sum_{S\in{[m]\choose n-1}}\det(C_{[n-1],S})^2.
\end{aligned}
$$</p>
<p>The next lemma gives a key observation to prove the matrix-tree theorem.</p>
<blockquote>
<p>Lemma
For any  \(S\subseteq [m]\)  of size  \(n − 1\) , the value of  \(\det(C[n − 1],S)\)  is either  \(1\) , or  \(-1\) , or  \(0\) . Moreover,  \(\det(C_{[n-1],S})=\pm1\)  if and only if  \(S\)  indicates a spanning tree in  \(G\) .</p>
</blockquote>
<blockquote>
<p>Proof.
We first show  \(\det(C_{[n-1],S})\in\{0,1,-1\}\)  by induction on  \(n\) . Note that  \(C_{[n − 1],S}\)  is an  \((n-1)\times (n-1)\)  matrix such that each column contains at most one  \(1\)  and at most one  \(-1\) , and all other entries are  \(0\) . For such matrix, when  \(n − 1 = 1\) , the induction hypothesis  \(\det(C_{[n-1],S})\in\{0,1,-1\}\)  is trivially true. And for general  \(n\) , if every column has a  \(1\)  and a  \(-1\) , then the sum of all rows is the zero vector, so the matrix is singular. Otherwise, expand the determinant by a column with one nonzero entry to find it is  \(\pm1\)  times the determinant of a smaller matrix of the same property, which by induction hypothesis has value  \(0\)  or  \(\pm1\) .</p>
<p>We then show that  \(\det(C_{[n − 1],S})\)  is nonzero if and only if  \(S\)  is a spanning tree.</p>
<p>Suppose the  \(n − 1\)  edges corresponding to  \(S\)  is not a spanning tree of  \(G\) . Then  \(S\)  must have more than one components, and there must be a component  \(R\)  not containing vertex  \(i\) . The rows of  \(C_{[n − 1],S}\)  corresponding to  \(R\)  add to  \(0\) , thus these rows are linearly dependent, and hence  \(\det(C_{[n − 1],S}) = 0\) .</p>
<p>Suppose the  \(n − 1\)  edges corresponding to  \(S\)  is a spanning tree of  \(G\) . Then there is a vertex  \(j_1\neq i\)  of degree  \(1\)  in  \(S\) ; let  \(e_1\)  be the edge in  \(S\)  incident to  \(j_1\) . Deleting vertex  \(j_1\)  and edge  \(e_1\)  from  \(S\) , we obtain a tree of  \(n − 2\)  edges. Again there is a vertex  \(j_2\neq i\)  of degree  \(1\)  with incident edge  \(e_2\) . Continue this we enumerate all vertices except  \(i\)  as  \(j_1,j_2,\ldots,j_{n-1}\)  and all edges in  \(S\)  as  \(e_1,e_2,\ldots,e_{n-1}\) . Now permute the rows and columns of  \(C_{[n − 1],S}\)  such that the  \(k\) -th row corresponds to vertex  \(j_k\)  and the  \(k\) -th column corresponds to  \(e_k\) . By our construction the permuted  \(C_{[n − 1],S}\)  is lower triangle with  \(\pm1\)  diagonal entries, since when each  \(j_k\)  is removed it is of degree  \(1\)  in the remaining tree and is incident to edge  \(e_k\) . Therefore,  \(\det(C_{[n-1],S})=\pm1\) .</p>
<p> \(\square\) </p>
</blockquote>
<p>The matrix-tree theorem follows as consequence. Recall we show that
$$
\begin{aligned}
\det(L_{i,i})
&amp;=\sum_{S\in{[m]\choose n-1}}\det(C_{[n-1],S})^2.
\end{aligned}
$$</p>
<p>The sum enumerates over all subgraphs  \(S\)  of  \(n − 1\)  edges, and by the above lemma  \(\det(C_{[n − 1],S})2 = 1\)  if and only if  \(S\)  is a spanning tree in  \(G\) . Therefore,  \(\det(L_{i,i})\)  gives the number of spanning trees in  \(G\) .</p>
<h2>Cayley&#x27;s formula by the matrix-tree theorem</h2>
<p>he number of trees of n distinct vertices equals the number of spanning trees in the complete graph  \(K_n\) . For  \(G = K_n\) , for any  \(i\in[n]\)  the  \((n-1)\times (n-1)\)  matrix  \(L_{i,i}\)  is given by</p>
<p>$$
L_{i,i}=
\begin{bmatrix}
n-1 &amp; -1 &amp; \cdots &amp; -1\\
-1 &amp; n-1 &amp; \cdots &amp; -1\\
\vdots &amp; \vdots &amp; \ddots &amp; -1\\
-1 &amp; -1 &amp; \cdots &amp; n-1
\end{bmatrix},
$$
whose determinant is  \(\det(L_{i,i}) = n^{n − 2}\) .</p>
<div style="text-align: right"> Re-typesetted by  </div>
<div style="text-align: right"> [$\texttt{AUGPath}$](https://space.bilibili.com/13246364)  </div>
<div style="text-align: right"> with sincere gratitude.  </div>


    <hr>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/gangdong/gangdong.github.io@dev/assets/js/md5.min.js"></script>
    <div id="comments" class="hidden"></div>

    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
    </script>
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    <script>
    
      var MD5 = function(d){var r = M(V(Y(X(d),8*d.length)));return r.toLowerCase()};function M(d){for(var _,m="0123456789ABCDEF",f="",r=0;r<d.length;r++)_=d.charCodeAt(r),f+=m.charAt(_>>>4&15)+m.charAt(15&_);return f}function X(d){for(var _=Array(d.length>>2),m=0;m<_.length;m++)_[m]=0;for(m=0;m<8*d.length;m+=8)_[m>>5]|=(255&d.charCodeAt(m/8))<<m%32;return _}function V(d){for(var _="",m=0;m<32*d.length;m+=8)_+=String.fromCharCode(d[m>>5]>>>m%32&255);return _}function Y(d,_){d[_>>5]|=128<<_%32,d[14+(_+64>>>9<<4)]=_;for(var m=1732584193,f=-271733879,r=-1732584194,i=271733878,n=0;n<d.length;n+=16){var h=m,t=f,g=r,e=i;f=md5_ii(f=md5_ii(f=md5_ii(f=md5_ii(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_hh(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_gg(f=md5_ff(f=md5_ff(f=md5_ff(f=md5_ff(f,r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+0],7,-680876936),f,r,d[n+1],12,-389564586),m,f,d[n+2],17,606105819),i,m,d[n+3],22,-1044525330),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+4],7,-176418897),f,r,d[n+5],12,1200080426),m,f,d[n+6],17,-1473231341),i,m,d[n+7],22,-45705983),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+8],7,1770035416),f,r,d[n+9],12,-1958414417),m,f,d[n+10],17,-42063),i,m,d[n+11],22,-1990404162),r=md5_ff(r,i=md5_ff(i,m=md5_ff(m,f,r,i,d[n+12],7,1804603682),f,r,d[n+13],12,-40341101),m,f,d[n+14],17,-1502002290),i,m,d[n+15],22,1236535329),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+1],5,-165796510),f,r,d[n+6],9,-1069501632),m,f,d[n+11],14,643717713),i,m,d[n+0],20,-373897302),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+5],5,-701558691),f,r,d[n+10],9,38016083),m,f,d[n+15],14,-660478335),i,m,d[n+4],20,-405537848),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+9],5,568446438),f,r,d[n+14],9,-1019803690),m,f,d[n+3],14,-187363961),i,m,d[n+8],20,1163531501),r=md5_gg(r,i=md5_gg(i,m=md5_gg(m,f,r,i,d[n+13],5,-1444681467),f,r,d[n+2],9,-51403784),m,f,d[n+7],14,1735328473),i,m,d[n+12],20,-1926607734),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+5],4,-378558),f,r,d[n+8],11,-2022574463),m,f,d[n+11],16,1839030562),i,m,d[n+14],23,-35309556),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+1],4,-1530992060),f,r,d[n+4],11,1272893353),m,f,d[n+7],16,-155497632),i,m,d[n+10],23,-1094730640),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+13],4,681279174),f,r,d[n+0],11,-358537222),m,f,d[n+3],16,-722521979),i,m,d[n+6],23,76029189),r=md5_hh(r,i=md5_hh(i,m=md5_hh(m,f,r,i,d[n+9],4,-640364487),f,r,d[n+12],11,-421815835),m,f,d[n+15],16,530742520),i,m,d[n+2],23,-995338651),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+0],6,-198630844),f,r,d[n+7],10,1126891415),m,f,d[n+14],15,-1416354905),i,m,d[n+5],21,-57434055),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+12],6,1700485571),f,r,d[n+3],10,-1894986606),m,f,d[n+10],15,-1051523),i,m,d[n+1],21,-2054922799),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+8],6,1873313359),f,r,d[n+15],10,-30611744),m,f,d[n+6],15,-1560198380),i,m,d[n+13],21,1309151649),r=md5_ii(r,i=md5_ii(i,m=md5_ii(m,f,r,i,d[n+4],6,-145523070),f,r,d[n+11],10,-1120210379),m,f,d[n+2],15,718787259),i,m,d[n+9],21,-343485551),m=safe_add(m,h),f=safe_add(f,t),r=safe_add(r,g),i=safe_add(i,e)}return Array(m,f,r,i)}function md5_cmn(d,_,m,f,r,i){return safe_add(bit_rol(safe_add(safe_add(_,d),safe_add(f,i)),r),m)}function md5_ff(d,_,m,f,r,i,n){return md5_cmn(_&m|~_&f,d,_,r,i,n)}function md5_gg(d,_,m,f,r,i,n){return md5_cmn(_&f|m&~f,d,_,r,i,n)}function md5_hh(d,_,m,f,r,i,n){return md5_cmn(_^m^f,d,_,r,i,n)}function md5_ii(d,_,m,f,r,i,n){return md5_cmn(m^(_|~f),d,_,r,i,n)}function safe_add(d,_){var m=(65535&d)+(65535&_);return(d>>16)+(_>>16)+(m>>16)<<16|65535&m}function bit_rol(d,_){return d<<_|d>>>32-_}
      console.log(location.pathname)
      console.log(MD5(location.pathname))
      
      const gitment = new Gitment({
        id: MD5(location.pathname),
        owner: 'shzaiz',
        repo: 'wiki-comments',
        oauth: {
          client_id: '29ea7d42268db12c5dcb',
          client_secret: 'c0eb4f0b456aef833271ee26e9a73297e93724ed',
        },
      })

      // gitment.render('comments')
    </script>
   
  </body>
</html>