<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex, nofollow">
    <style>
        body {counter-reset:section;}
        h1 {counter-reset:subsection;font-size:x-large;}
        h2 {font-size: large;}

        h1:before {
        counter-increment:section;
        content:"Section " counter(section) ". ";
            font-weight:bold;
            font-size: x-large;
        }
        h2:before {
        counter-increment:subsection;
        content:counter(section) "." counter(subsection) " ";
        font-size: large;
        }
        html, body {
            margin: 3%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        } 

        pre {
            font-family: 'Courier New', Courier, monospace;
        } 

        .navbar {
            overflow: hidden;
            background-color: #333;
            position: fixed; /* Set the navbar to fixed position */
            top: 0; /* Position the navbar at the top of the page */
            width: 100%; /* Full width */
        }

        .navbar a {
            float: left;
            display: block;
            color: #f2f2f2;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }

        a {
            color: #148bca;
            text-align: center;
            padding-left: 10px;
            padding-right: 10px;
            text-decoration: none;
        }

    </style>
  </head>
  <body>
    
    <div class="navbar">
        <a href="https://shzaiz.github.io">AUG's Wiki</a>
        <a href="index.html"> ↑ Back to contents</a>
    </div>


    <h1>知识点</h1>
<ul>
<li>Eucluid算法</li>
<li>Extended Eucluid算法
<ul>
<li>怎么相乘?</li>
<li>之后的最小非负整数解是多少?</li>
</ul>
</li>
<li>埃氏筛
<ul>
<li>注意第二重循环</li>
</ul>
</li>
<li>Euler筛法
<ul>
<li>怎么保证用最小的素因子筛掉?</li>
</ul>
</li>
<li>质因数分解
<ul>
<li>暴力即可.</li>
</ul>
</li>
</ul>
<h1>参考代码</h1>
<p><strong>gcd</strong>.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">gcd</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>b){
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">if</span>(b<span style="color: #666666">==0</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>a;
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>gcd(b,a<span style="color: #666666">%</span>b);
}
</pre></div>

<p><strong>exgcd</strong>.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">exgcd</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>a,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>b,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>x,<span style="color: #bbbbbb"> </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;</span>y){
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">if</span>(b<span style="color: #666666">==0</span>)<span style="color: #bbbbbb"> </span>{x<span style="color: #666666">=1</span>,y<span style="color: #666666">=0</span>;<span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>a;}
<span style="color: #bbbbbb">    </span><span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>r<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>exgcd(b,a<span style="color: #666666">%</span>b,x,y);
<span style="color: #bbbbbb">    </span>tie(x,y)<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>make_tuple(y,x<span style="color: #666666">-</span>(a<span style="color: #666666">/</span>b)<span style="color: #666666">*</span>y);
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">return</span><span style="color: #bbbbbb"> </span>r;
}
</pre></div>

<p><strong>Euler筛法</strong>.</p>
<p>对应的正确性说明:</p>
<p>Note that every composite  \(q\)  must have at least one prime factor, so we can pick the smallest prime factor  \(p\) , and let the rest of the part be  \(i\) , i.e.  \(q = ip\) . Since  \(p\)  is the smallest prime factor, we have  \(i ≥ p\) , and no prime less than  \(p\)  can divide  \(i\) . Now let us take a look at the code we have a moment ago. When we loop for every  \(i\) , all primes not exceeding  \(i\)  is already recorded in the container prime. Therefore, if we only loop for all elements in prime in the inner loop, breaking out when the element divides  \(i\) , we can pick out each composite exactly once.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #008000; font-weight: bold">for</span>(LL<span style="color: #bbbbbb"> </span>i<span style="color: #666666">=2</span>;i<span style="color: #666666">&lt;=</span>N;i<span style="color: #666666">++</span>){
<span style="color: #bbbbbb">    </span><span style="color: #008000; font-weight: bold">if</span>(<span style="color: #666666">!</span>notp[i])<span style="color: #bbbbbb"> </span>prime[<span style="color: #666666">++</span>cnt]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">	</span><span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>j<span style="color: #666666">=1</span>;j<span style="color: #666666">&lt;=</span>cnt<span style="color: #bbbbbb"> </span><span style="color: #666666">&amp;&amp;</span><span style="color: #bbbbbb"> </span>i<span style="color: #666666">*</span>prime[j]<span style="color: #666666">&lt;=</span>N;j<span style="color: #666666">++</span>){
<span style="color: #bbbbbb">		</span>notp[i<span style="color: #666666">*</span>prime[j]]<span style="color: #666666">=1</span>;
<span style="color: #bbbbbb">		</span><span style="color: #008000; font-weight: bold">if</span>(i<span style="color: #666666">%</span>prime[j]<span style="color: #666666">==0</span>)<span style="color: #bbbbbb"> </span><span style="color: #008000; font-weight: bold">break</span>;
<span style="color: #bbbbbb">	</span>}
}<span style="color: #bbbbbb">	</span>
</pre></div>

<p><strong>埃氏筛</strong>.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span><span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">Prime</span>(){
<span style="color: #bbbbbb">	</span><span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>i<span style="color: #666666">=2</span>;i<span style="color: #666666">&lt;=</span>N;i<span style="color: #666666">++</span>){
<span style="color: #bbbbbb">		</span><span style="color: #008000; font-weight: bold">if</span>(notp[i]<span style="color: #666666">==0</span>){
<span style="color: #bbbbbb">			</span>prime[<span style="color: #666666">++</span>cnt]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>i;
<span style="color: #bbbbbb">			</span><span style="color: #008000; font-weight: bold">for</span>(<span style="color: #B00040">int</span><span style="color: #bbbbbb"> </span>j<span style="color: #666666">=2*</span>i;<span style="color: #bbbbbb"> </span>j<span style="color: #666666">&lt;=</span>N;j<span style="color: #666666">+=</span>i){
<span style="color: #bbbbbb">				</span>notp[j]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">1</span>;
<span style="color: #bbbbbb">				</span>
<span style="color: #bbbbbb">			</span>}
<span style="color: #bbbbbb">		</span>}
<span style="color: #bbbbbb">	</span>}
}
</pre></div>

<p><strong>质因数分解</strong>.</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%;"><span></span>vector<span style="color: #666666">&lt;</span>ll<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;</span><span style="color: #bbbbbb"> </span>fac;
ll<span style="color: #bbbbbb"> </span>tim[MAXN];
<span style="color: #B00040">void</span><span style="color: #bbbbbb"> </span><span style="color: #0000FF">get</span>(ll<span style="color: #bbbbbb"> </span>n){
<span style="color: #bbbbbb">	</span>fac.clear();
<span style="color: #bbbbbb">	</span><span style="color: #008000; font-weight: bold">for</span>(ll<span style="color: #bbbbbb"> </span>i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;=100</span>;i<span style="color: #666666">++</span>)<span style="color: #bbbbbb"> </span>tim[i]<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span><span style="color: #666666">0</span>;;
<span style="color: #bbbbbb">	</span><span style="color: #008000; font-weight: bold">for</span>(ll<span style="color: #bbbbbb"> </span>i<span style="color: #666666">=2</span>;i<span style="color: #666666">&lt;=</span>n<span style="color: #666666">/</span>i;i<span style="color: #666666">++</span>){
<span style="color: #bbbbbb">		</span><span style="color: #008000; font-weight: bold">if</span>(n<span style="color: #666666">%</span>i<span style="color: #666666">==0</span>){
<span style="color: #bbbbbb">			</span>fac.push_back(i);
<span style="color: #bbbbbb">			</span><span style="color: #008000; font-weight: bold">while</span>(n<span style="color: #666666">%</span>i<span style="color: #666666">==0</span>)<span style="color: #bbbbbb"> </span>{n<span style="color: #666666">/=</span>i;<span style="color: #bbbbbb"> </span>tim[fac.size()<span style="color: #666666">-1</span>]<span style="color: #666666">++</span>;}
<span style="color: #bbbbbb">		</span>}
<span style="color: #bbbbbb">	</span>}
<span style="color: #bbbbbb">	</span><span style="color: #008000; font-weight: bold">if</span>(n<span style="color: #666666">&gt;1</span>)<span style="color: #bbbbbb"> </span>{fac.push_back(n);tim[fac.size()<span style="color: #666666">-1</span>]<span style="color: #666666">++</span>;}
<span style="color: #bbbbbb">	</span>ll<span style="color: #bbbbbb"> </span>ssz<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>fac.size();
<span style="color: #bbbbbb">	</span><span style="color: #008000; font-weight: bold">for</span>(ll<span style="color: #bbbbbb"> </span>i<span style="color: #666666">=</span>ssz<span style="color: #666666">-1</span>;i<span style="color: #666666">&gt;=0</span>;i<span style="color: #666666">--</span>){
<span style="color: #bbbbbb">		</span>printf(<span style="color: #BA2121">&quot;%lld %d &quot;</span>,<span style="color: #bbbbbb"> </span>fac[i],<span style="color: #bbbbbb"> </span>tim[i]);
<span style="color: #bbbbbb">		</span>
<span style="color: #bbbbbb">	</span>}<span style="color: #3D7B7B; font-style: italic">// O sqrt n</span>
}
</pre></div>

<h1>例题</h1>
<h2>青蛙的约会</h2>
<p>注意好如果有两个变量的话, 注意谁是定的, 谁是动的.</p>
<p>还有注意最小正整数解的构造, 加的倍数是另一个来除.</p>
<h2>Sum of Consecutive Prime Numbers</h2>
<p>注意双指针的方法. 有两个branch cutting需要注意:</p>
<ul>
<li>当<code>prime[i]&gt;n</code>的时候, 就不用在搜索了. 因为肯定不满足.</li>
<li>双指针的方法:
- 在运行的时候求和, 并且用两个指针 \(l,i\) 来指示左右区间.</li>
</ul>
<h2>Prime Distance</h2>
<p>注意本题目是区间筛, 在得到了一定的质数之后可以对它们求所在区间进行一个筛就行了.</p>
<p>本题目测试点有点坑人, 有时候 \(i+L&lt;2\) 的情况也被考虑在内, 因此无法通过.</p>
<h2>Prime Land</h2>
<p>本题目数据只有 \(32767\) , 很水, 略.</p>
<h2>X-factor Chains</h2>
<p>有两问, 假设唯一分解是 \(\prod_{i}p_i^{\alpha_i}\) , 那么第一问是 \(|\sum i|\) , 第二问是 \({m\choose \alpha_1}{m-\alpha_1\choose \alpha_2}\cdots {1\choose 1}\) .</p>
<p>数据比较水.</p>
<h1>补充习题</h1>
<h2>Luogu P5656 exgcd</h2>
<p>注意调试工具的应用. 以及精度的方法.</p>


    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
    </script>
  </body>
</html>